/// <reference types="node" />
import { EventEmitter } from 'node:events';
import * as Cucumber from '@cucumber/cucumber';
import type { World as WorldType } from '@cucumber/cucumber';
import type { GherkinDocument } from '@cucumber/messages';
import type { Capabilities, Options } from '@wdio/types';
import type { CucumberOptions, StepDefinitionOptions, HookFunctionExtension as HookFunctionExtensionImport } from './types.js';
declare const After: (<WorldType_1 = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_1>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestCaseHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_2>) => void), AfterAll: ((code: Function) => void) & ((options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestRunHookOptions, code: Function) => void), AfterStep: (<WorldType_1 = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_1>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestStepHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_2>) => void), Before: (<WorldType_1 = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_1>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestCaseHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestCaseHookFunction<WorldType_2>) => void), BeforeAll: ((code: Function) => void) & ((options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestRunHookOptions, code: Function) => void), BeforeStep: (<WorldType_1 = Cucumber.IWorld<any>>(code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_1>) => void) & (<WorldType_1 = Cucumber.IWorld<any>>(tags: string, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_1>) => void) & (<WorldType_2 = Cucumber.IWorld<any>>(options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineTestStepHookOptions, code: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").TestStepHookFunction<WorldType_2>) => void), Given: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep, Then: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep, When: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep, DataTable: typeof Cucumber.DataTable, World: typeof Cucumber.World, setDefaultTimeout: (milliseconds: number) => void, setDefinitionFunctionWrapper: (fn: Function) => void, setWorldConstructor: (fn: any) => void, defineParameterType: (options: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IParameterTypeDefinition<any>) => void, defineStep: import("@cucumber/cucumber/lib/support_code_library_builder/types.js").IDefineStep;
declare class CucumberAdapter {
    private _cid;
    private _config;
    private _specs;
    private _capabilities;
    private _reporter;
    private _cwd;
    private _newId;
    private _cucumberOpts;
    private _hasTests;
    private _cucumberFeaturesWithLineNumbers;
    private _eventBroadcaster;
    private _cucumberReporter;
    private _eventDataCollector;
    private _pickleFilter;
    private getHookParams?;
    private gherkinParser;
    constructor(_cid: string, _config: Options.Testrunner, _specs: string[], _capabilities: Capabilities.RemoteCapability, _reporter: EventEmitter);
    readFiles(filePaths?: Options.Testrunner['specs']): (string | string[])[];
    getGherkinDocuments(files?: Options.Testrunner['specs']): (GherkinDocument | GherkinDocument[])[];
    filterSpecsByTagExpression(specs?: Options.Testrunner['specs'], tagExpression?: string): typeof specs;
    init(): Promise<this>;
    hasTests(): boolean;
    run(): Promise<number>;
    /**
     * Transpilation https://github.com/cucumber/cucumber-js/blob/master/docs/cli.md#transpilation
     * Usage: `['module']`
     * we extend it a bit with ability to init and pass configuration to modules.
     * Pass an array with path to module and its configuration instead:
     * Usage: `[['module', {}]]`
     * Or pass your own function
     * Usage: `[() => { require('@babel/register')({ ignore: [] }) }]`
     */
    registerRequiredModules(): Promise<void[]>;
    requiredFiles(): string[];
    loadSpecFiles(): Promise<void>;
    /**
     * set `beforeFeature`, `afterFeature`, `beforeScenario`, `afterScenario`, 'beforeStep', 'afterStep'
     * @param {object} config config
     */
    addWdioHooks(config: Options.Testrunner): void;
    /**
     * wraps step definition code with sync/async runner with a retry option
     * @param {object} config
     */
    wrapSteps(config: Options.Testrunner): void;
    /**
     * wrap step definition to enable retry ability
     * @param   {Function}  code            step definition
     * @param   {boolean}   isStep
     * @param   {object}    config
     * @param   {string}    cid             cid
     * @param   {StepDefinitionOptions} options
     * @param   {Function}  getHookParams  step definition
     * @return  {Function}                  wrapped step definition for sync WebdriverIO code
     */
    wrapStep(code: Function, isStep: boolean, config: Options.Testrunner, cid: string, options: StepDefinitionOptions, getHookParams: Function): (this: WorldType, ...args: any[]) => Promise<unknown>;
}
declare const adapterFactory: {
    init?: Function;
};
export default adapterFactory;
export { CucumberAdapter, adapterFactory, After, AfterAll, AfterStep, Before, BeforeAll, BeforeStep, DataTable, defineParameterType, defineStep, Given, setDefaultTimeout, setDefinitionFunctionWrapper, setWorldConstructor, Then, When, World };
declare global {
    namespace WebdriverIO {
        interface CucumberOpts extends CucumberOptions {
        }
        interface HookFunctionExtension extends HookFunctionExtensionImport {
        }
    }
}
//# sourceMappingURL=index.d.ts.map