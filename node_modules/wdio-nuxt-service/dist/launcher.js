var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NuxtServiceLauncher_options, _NuxtServiceLauncher_currentHandler, _NuxtServiceLauncher_currentNuxt, _NuxtServiceLauncher_distWatcher;
import { existsSync, readdirSync } from 'node:fs';
import logger from '@wdio/logger';
import getPort from 'get-port';
import chokidar from 'chokidar';
import { listen } from 'listhen';
import { setupDotenv } from 'c12';
import { toNodeListener } from 'h3';
import { withTrailingSlash } from 'ufo';
import { debounce } from 'perfect-debounce';
import { SevereServiceError } from 'webdriverio';
import { resolve, relative, normalize } from 'pathe';
import { loadNuxt, loadNuxtConfig, buildNuxt } from '@nuxt/kit';
import { pkg } from './constants.js';
import { writeNuxtManifest, loadNuxtManifest, cleanupNuxtDirs } from './utils.js';
const log = logger('wdio-nuxt-service');
export class NuxtServiceLauncher {
    constructor(options) {
        _NuxtServiceLauncher_options.set(this, void 0);
        _NuxtServiceLauncher_currentHandler.set(this, void 0);
        _NuxtServiceLauncher_currentNuxt.set(this, void 0);
        _NuxtServiceLauncher_distWatcher.set(this, void 0);
        log.info(`Initiate Nuxt Service (v${pkg.version})`);
        __classPrivateFieldSet(this, _NuxtServiceLauncher_options, {
            rootDir: process.cwd(),
            dotenv: '.env',
            hostname: 'localhost',
            ...options
        }, "f");
    }
    async onPrepare() {
        let loadingMessage = 'Nuxt is starting...';
        const loadingHandler = (_req, res) => {
            res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            res.statusCode = 503; // Service Unavailable
            res.end('Loading Nuxt server...');
        };
        const serverHandler = (req, res) => (__classPrivateFieldGet(this, _NuxtServiceLauncher_currentHandler, "f")
            ? __classPrivateFieldGet(this, _NuxtServiceLauncher_currentHandler, "f").call(this, req, res)
            : loadingHandler(req, res));
        await setupDotenv({ cwd: __classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").rootDir, fileName: __classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").dotenv });
        const config = await loadNuxtConfig({
            cwd: __classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").rootDir,
            overrides: { dev: true }
        });
        const runHTTPS = (__classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").https !== false && (__classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").https || config.devServer.https));
        const serverOptions = {
            showURL: false,
            port: __classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").port || process.env.NUXT_PORT || config.devServer.port || await getPort(),
            hostname: __classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").hostname || process.env.NUXT_HOST || config.devServer.host,
            https: runHTTPS
                ? {
                    cert: (__classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").sslCert
                        || (config.devServer.https && config.devServer.https.cert)
                        || undefined),
                    key: (__classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").sslKey
                        || (config.devServer.https && config.devServer.https.key)
                        || undefined)
                }
                : false
        };
        const listener = await listen(serverHandler, serverOptions);
        const showURL = () => {
            log.info(`Nuxt is ready at ${withTrailingSlash(listener.url.toString())}`);
        };
        const load = async (isRestart, reason) => {
            try {
                loadingMessage = `${reason ? `${reason}. ` : ''}${isRestart ? 'Restarting' : 'Starting'} nuxt...`;
                __classPrivateFieldSet(this, _NuxtServiceLauncher_currentHandler, undefined, "f");
                if (isRestart) {
                    log.info(loadingMessage);
                }
                if (__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f")) {
                    await __classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f").close();
                }
                if (__classPrivateFieldGet(this, _NuxtServiceLauncher_distWatcher, "f")) {
                    await __classPrivateFieldGet(this, _NuxtServiceLauncher_distWatcher, "f").close();
                }
                const currentNuxt = __classPrivateFieldSet(this, _NuxtServiceLauncher_currentNuxt, await loadNuxt({
                    rootDir: __classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").rootDir,
                    dev: true,
                    ready: false
                }), "f");
                currentNuxt.hooks.hookOnce('restart', () => load(true));
                if (!isRestart) {
                    showURL();
                }
                __classPrivateFieldSet(this, _NuxtServiceLauncher_distWatcher, chokidar.watch(resolve(currentNuxt.options.buildDir, 'dist'), { ignoreInitial: true, depth: 0 }), "f");
                __classPrivateFieldGet(this, _NuxtServiceLauncher_distWatcher, "f").on('unlinkDir', () => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    dLoad(true, '.nuxt/dist directory has been removed');
                });
                // Write manifest and also check if we need cache invalidation
                if (!isRestart) {
                    const previousManifest = await loadNuxtManifest(currentNuxt.options.buildDir);
                    const newManifest = await writeNuxtManifest(currentNuxt);
                    if (previousManifest && newManifest && previousManifest._hash !== newManifest._hash) {
                        await cleanupNuxtDirs(currentNuxt.options.rootDir);
                    }
                }
                await currentNuxt.ready();
                await currentNuxt.hooks.callHook('listen', listener.server, listener);
                const address = listener.server.address();
                currentNuxt.options.devServer.url = listener.url;
                currentNuxt.options.devServer.port = address.port;
                currentNuxt.options.devServer.host = address.address;
                currentNuxt.options.devServer.https = listener.https;
                await buildNuxt(currentNuxt);
                process.env.WDIO_BASE_URL = listener.url;
                __classPrivateFieldSet(this, _NuxtServiceLauncher_currentHandler, toNodeListener(currentNuxt.server.app), "f");
                if (isRestart) {
                    showURL();
                }
            }
            catch (err) {
                const msg = `Cannot ${isRestart ? 'restart' : 'start'} nuxt: ${err.stack}`;
                log.error(msg);
                __classPrivateFieldSet(this, _NuxtServiceLauncher_currentHandler, undefined, "f");
                throw new SevereServiceError(msg);
            }
        };
        // Watch for config changes
        // TODO: Watcher service, modules, and requireTree
        const dLoad = debounce(load);
        const watcher = chokidar.watch(__classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").rootDir, { ignoreInitial: true, depth: 1 });
        watcher.on('all', (event, _file) => {
            if (!__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f")) {
                return;
            }
            const file = normalize(_file);
            const buildDir = withTrailingSlash(normalize(__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f").options.buildDir));
            if (file.startsWith(buildDir)) {
                return;
            }
            const relativePath = relative(__classPrivateFieldGet(this, _NuxtServiceLauncher_options, "f").rootDir, file);
            if (file.match(/(nuxt\.config\.(js|ts|mjs|cjs)|\.nuxtignore|\.env|\.nuxtrc)$/)) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                dLoad(true, `${relativePath} updated`);
            }
            const isDirChange = ['addDir', 'unlinkDir'].includes(event);
            const isFileChange = ['add', 'unlink'].includes(event);
            const pagesDir = resolve(__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f").options.srcDir, __classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f").options.dir.pages);
            const reloadDirs = ['components', 'composables', 'utils'].map((d) => resolve(__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f")?.options.srcDir, d));
            if (isDirChange) {
                if (reloadDirs.includes(file)) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    dLoad(true, `Directory \`${relativePath}/\` ${event === 'addDir' ? 'created' : 'removed'}`);
                    return;
                }
            }
            if (isFileChange) {
                if (file.match(/(app|error|app\.config)\.(js|ts|mjs|jsx|tsx|vue)$/)) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    dLoad(true, `\`${relativePath}\` ${event === 'add' ? 'created' : 'removed'}`);
                    return;
                }
            }
            if (file.startsWith(pagesDir)) {
                const hasPages = existsSync(pagesDir) ? readdirSync(pagesDir).length > 0 : false;
                if (__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f") && !__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f").options.pages && hasPages) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    dLoad(true, 'Pages enabled');
                    return;
                }
                if (__classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f") && __classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f").options.pages && !hasPages) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    dLoad(true, 'Pages disabled');
                    // eslint-disable-next-line no-useless-return
                    return;
                }
            }
        });
        await load(false);
    }
    async onComplete() {
        log.info('Stop Nuxt server');
        __classPrivateFieldSet(this, _NuxtServiceLauncher_currentHandler, undefined, "f");
        await __classPrivateFieldGet(this, _NuxtServiceLauncher_currentNuxt, "f")?.close();
        await __classPrivateFieldGet(this, _NuxtServiceLauncher_distWatcher, "f")?.close();
    }
}
_NuxtServiceLauncher_options = new WeakMap(), _NuxtServiceLauncher_currentHandler = new WeakMap(), _NuxtServiceLauncher_currentNuxt = new WeakMap(), _NuxtServiceLauncher_distWatcher = new WeakMap();
//# sourceMappingURL=launcher.js.map